\chapter{Analyse des données}

TODO : décrire vite fait chaque table ?
TODO : raconter ce qu'on a découvert dans les données et comment (sans requêtes SQL) -> les données ne sont pas bonnes, nous les avons vérifiées, grâce à des requêtes (vérifications internes) et à d'autres sources externes (wikipédia...)
 - les causes de morts qui s'imbriquent
 - la somme de niveau 1 différentes de celles de niveau 2
 - les données des années 79 - 80 sont des estimations (chiffres ronds) car absence de données pour ces années là
 - pour les néoplasies, les causes renseignées pour la mort sont les causes les plus précises (plus d'imbrications des causes et donc de doublons des morts)


\pagebreak


\chapter{Modélisation de l'entrepôt et des cubes}

\section{Hypercube Population}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\linewidth]{images/pop/cube.png}
    \caption{Modèle conceptuel de l'hypercube Population}
    \label{conception_cube_pop}
\end{figure}

\section{Hypercube Nombre de morts}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\linewidth]{images/cubeNbMorts.png}
    \caption{Modèle conceptuel de l'hypercube Nombre de morts}
    \label{conception_cube_nombre_morts}
\end{figure}

\section{Hypercube Néoplasies}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\linewidth]{images/cubeNeo.png}
    \caption{Modèle conceptuel de l'hypercube Néoplasies}
    \label{conception_cube_néoplasies}
\end{figure}

\section{Entrepôt}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\linewidth]{images/cubeNeo.png}
    \caption{Modèle logique de l'entrepôt}
    \label{conception_cube_néoplasies}
\end{figure}


\pagebreak


\chapter{Transformations des tables d'origine}

TODO : enlever les requetes SQL, reformuler pour avoir pour chaque transfo : les sources, la destination et les opérations effectuées) et completer les transformations réalisées pour tous les cubes

\section{Séparation des données de sexe et d'age}

    Vu le format des données de la table SexAge, dissocier l'effet du sexe et de l'âge s'avérait hardu.

    Nous avons donc modifié la table en créant deux nouvelles colonnes: Sex, nvarchar qui contiendra le sexe (M/F), et Age,
    nvarchar qui contiendra la tranche d'âge (<1, 10-14, ...).

    Nous avons alors lancé la requête suivante afin de séparer les données de ``sexage'' sur ces deux colonnes :

    \begin{lstlisting}[frame=single, language=SQL]
UPDATE sexage
SET Sex=LEFT(label, 1), Age=RIGHT(label, LEN(label) - 1);
    \end{lstlisting}

\section{Table temporelle}

    Requête pour initialiser la table \textit{year} après sa création (une colonne de type entier et clé primaire)

    \begin{lstlisting}[frame=single, language=SQL]
INSERT INTO Annee
SELECT     [YEAR]
FROM [7992pops]
GROUP BY [YEAR]
ORDER BY [YEAR]
    \end{lstlisting}

\section{Visualisation des données}

    Nous avons exploré les données mises à notre disposition, en essayant de trouver des motifs, incohérences et autres motifs particuliers
    dans ces dernières.

    Pour cela, nous avons effectué plusieurs requêtes SQL, comme cette requête qui donne la répartition des décès par sexe pour chaque
    cause.

    \begin{lstlisting}[frame=single, language=SQL]
SELECT sexage.SEX, causes.LABEL, COUNT(*) AS Number
FROM london INNER JOIN
    sexage ON london.SEXAGE = sexage.SEXAGE INNER JOIN
    causes on london.CAUSE = causes.CAUSE
GROUP BY sexage.sex, causes.label
    \end{lstlisting}

    On a donc découvert que, surprise !, il n'y a pas de décès ayant pour cause un avortement, chez le sexe masculin.

\section{Incohérences dans les nombre de morts}

    En analysant la table des morts de chaque région, nous avons remarqué que la somme des morts par cause de niveau 2 était
    inférieure au nombre de morts par cause de niveau 1 (càd de toutes les causes de mort).

    Si ceci est dû en partie à des certificats de décès qui ne sont pas correctement remplis, il existe aussi une autre cause,
    renseignée dans le document fourni (\textbf{``local mortaility datapack.pdf''})~: Un nouveau certificat pour les morts néonatales
    a été introduit en 1986, et ces morts ne sont plus rentrées sous la cause ``Certain conditions originating in the perinatal
    period'' depuis cette date là.

    On peut voir cette différence dans le nombre de morts de la table ``westmids'' (par exemple) avec la requête suivante :

    \begin{lstlisting}[frame=single, language=SQL]
SELECT causes.NIVEAU, SUM(westmids.DEATHS) AS TotalDeaths
FROM westmids INNER JOIN causes ON westmids.CAUSE = causes.CAUSE
GROUP BY causes.NIVEAU
HAVING (causes.NIVEAU = 1) OR (causes.NIVEAU = 2)
    \end{lstlisting}

    La solution qu'on a choisie est de rajouter une nouvelle cause de mort de niveau 2 représentant une cause indéfinie, afin
    de ne pas sous-estimer le nombre de morts en ignorant ceux dont la cause de niveau 2 n'est pas renseignée.

    La requête utilisée pour réaliser cette opération est détaillée plus bas, dans la partie exploitation de données.

\section{Union des données dans une nouvelle table}

    Afin d'exploiter ces données, nous avons créée deux nouvelles tables centralisant toutes les morts des différentes régions.

    Selon l'utilisation désirée (étude des causes de niveau 2, étude de la néoplasie), des conditions sont posées afin
    de minimiser le volume des données manipulées.

    Par exemple, pour l'étude des causes de niveau 2.

    \begin{lstlisting}[frame=single, language=SQL]
INSERT INTO deaths
SELECT *
FROM
(
    SELECT london.* FROM london INNER JOIN causes ON london.cause = causes.cause WHERE causes.niveau <= 2 UNION
    SELECT eastmids.* FROM eastmids INNER JOIN causes ON eastmids.cause = causes.cause WHERE causes.niveau <= 2 UNION
    ...
)
    \end{lstlisting}


\section{Exploitation des nouvelles données}

    Afin d'exploiter ces données, nous avons créée deux nouvelles tables centralisant toutes les morts des différentes régions.

    \begin{lstlisting}[frame=single, language=SQL]
SELECT deaths.*
FROM deaths INNER JOIN causes
        ON deaths.cause = causes.cause
WHERE causes.niveau <= 2
    \end{lstlisting}

    Et comme vu précédemment, il existe un gap entre le nombre total de morts si on regarde les causes de niveau 2 ou le nombre
    total de morts (cause de niveau 1).

    \begin{lstlisting}[frame=single, language=SQL]
SELECT causes.niveau, SUM(deaths.deaths)
FROM deaths INNER JOIN causes
        ON deaths.cause = causes.cause
    \end{lstlisting}

    Afin de corriger cette incohérence, nous rajoutons comme prévu une cause de niveau 2 représentant une cause non renseignée
    et lui donnons l'id \textit{120}.

    Nous exécutons alors cette requête qui va calculer le gap entre les morts de niveau 1 et de niveau 2, puis rajouter une ligne
    s'il y a des morts non renseignées (avec la cause que l'on vient de créer).

    \begin{lstlisting}[frame=single, language=SQL]
INSERT INTO deaths
SELECT h.year, h.county, h.cdistrict, 120, h.sexage, h.delta
FROM (
    SELECT t.year, t.county, t.cdistrict, t.sexage,
    (
        (
            SELECT sum(tt1.deaths)
            FROM deaths AS tt1, causes AS cc1
            WHERE tt1.cause = cc1.cause
            AND cc1.niveau = 1
            AND tt1.year = t.year
            AND tt1.county = t.county
            AND tt1.cdistrict = t.cdistrict
            AND tt1.sexage = t.sexage
        )
        -
        (
            SELECT sum(tt2.deaths)
            FROM deaths AS tt2, causes AS cc2
            WHERE tt2.cause = cc2.cause
            AND cc2.niveau = 2
            AND tt2.year = t.year
            AND tt2.county = t.county
            AND tt2.cdistrict = t.cdistrict
            AND tt2.sexage = t.sexage
        )
    ) AS delta
    FROM deaths AS t
    GROUP BY t.year, t.county, t.cdistrict, t.sexage
) AS h
WHERE h.delta > 0
    \end{lstlisting}

\pagebreak

\chapter{Indicateurs et validation}

TODO : trouver pour chaque cube des indicateurs et les utiliser pour montrer qu'on a validé nos données (c'est-à-dire que les données étaient toujours les mêmes avant et après nos modifications de tables)

\section{Population}
Les validations suivantes ont été appliquées sur le cube Population afin de valider l'intégrité des données de celui-ci. Les résultats obtenus lors de l'exploration du cube ont été recoupées avec les données des tables par les requêtes SQL adéquates :
\begin{itemize}
    \item Population totale en 1992 : 51 276 887
    \item Population totale en 1992 dans le 1er county : 6 904 554
    \item Population totale en 1992, de sexe masculin et d'âge inférieur à un an : 355 930
    \item Population totale en 1992, de sexe masculin et d'âge inférieur à un an dans le 1er district et le 1er county du cluster Central London : 18
\end{itemize}


\pagebreak
