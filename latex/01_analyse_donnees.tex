\chapter{Analyse des données}

\section{Visualisation des données}

    Requête utile pour voir la répartition des causes de décés selon le sexe :

    \begin{lstlisting}[frame=single, language=SQL]
SELECT sexage.SEX, causes.LABEL, COUNT(*) AS Number
FROM london INNER JOIN
        sexage ON london.SEXAGE = sexage.SEXAGE INNER JOIN
        causes on london.CAUSE = causes.CAUSE
GROUP BY sexage.sex, causes.label
    \end{lstlisting}

\section{Séparation des données de sexe et d'age}

    Vu le format des données de la table SexAge, dissocier l'effet du sexe et de l'âge s'avérait hardu.

    Nous avons donc modifié la table en créant deux nouvelles colonnes: Sex, nvarchar qui contiendra le sexe (M/F), et Age,
    nvarchar qui contiendra la tranche d'âge (<1, 10-14, ...).

    Nous avons alors lancé la requête suivante afin de séparer les données de ``sexage'' sur ces deux colonnes :

    \begin{lstlisting}[frame=single, language=SQL]
UPDATE sexage
SET Sex=LEFT(label, 1), Age=RIGHT(label, LEN(label) - 1);
    \end{lstlisting}

\section{Table temporelle}

    Requête pour initialiser la table \textit{year} après sa création (une colonne de type entier et clé primaire)

    \begin{lstlisting}[frame=single, language=SQL]
INSERT INTO Annee
SELECT     [YEAR]
FROM [7992pops]
GROUP BY [YEAR]
ORDER BY [YEAR]
    \end{lstlisting}

\section{Visualisation des données}

    Nous avons exploré les données mises à notre disposition, en essayant de trouver des motifs, incohérences et autres motifs particuliers
    dans ces dernières.

    Pour cela, nous avons effectué plusieurs requêtes SQL, comme cette requête qui donne la répartition des décès par sexe pour chaque
    cause.

    \begin{lstlisting}[frame=single, language=SQL]
SELECT sexage.SEX, causes.LABEL, COUNT(*) AS Number
FROM london INNER JOIN
    sexage ON london.SEXAGE = sexage.SEXAGE INNER JOIN
    causes on london.CAUSE = causes.CAUSE
GROUP BY sexage.sex, causes.label
    \end{lstlisting}

    On a donc découvert que, surprise !, il n'y a pas de décès ayant pour cause un avortement, chez le sexe masculin.

\section{Incohérences dans les nombre de morts}

    En analysant la table des morts de chaque région, nous avons remarqué que la somme des morts par cause de niveau 2 était
    inférieure au nombre de morts par cause de niveau 1 (càd de toutes les causes de mort).

    Cette incohérence peut être montrée sur la table ``westmids'' (par exemple) avec la requête suivante :

    \begin{lstlisting}[frame=single, language=SQL]
SELECT causes.NIVEAU, SUM(westmids.DEATHS) AS TotalDeaths
FROM westmids INNER JOIN causes ON westmids;CAUSE = causes.CAUSE
GROUP BY causes.NIVEAU
HAVING (causes.NIVEAU = 1) OR (causes.NIVEAU = 2)
    \end{lstlisting}

    Ceci est probablement dû à une erreur lors du remplissage des formulaires (cause de niveau 2 non-remplie).

    La solution qu'on propose est de rajouter une nouvelle cause de mort de niveau 2 représentant une cause indéfinie, afin
    de ne pas sous-estimer le nombre de morts en ignorant ceux dont la cause de niveau 2 n'est pas renseignée.

    \begin{lstlisting}[frame=single, language=SQL]
METTRE LES REQUETES QUI VONT BIEN ICI
    \end{lstlisting}

\section{Union des données dans une nouvelle table}

    Afin d'exploiter ces données, nous avons créée deux nouvelles tables centralisant toutes les morts des différentes régions.

    Selon l'utilisation désirée (étude des causes de niveau 2, étude de la néoplasie), des conditions sont posées afin
    de minimiser le volume des données manipulées.

    Par exemple, pour l'étude des causes de niveau 2.

    \begin{lstlisting}[frame=single, language=SQL]
INSERT INTO deaths
SELECT *
FROM
(
    SELECT london.* FROM london INNER JOIN causes ON london.cause = causes.cause WHERE causes.niveau <= 2 UNION
    SELECT eastmids.* FROM eastmids INNER JOIN causes ON eastmids.cause = causes.cause WHERE causes.niveau <= 2 UNION
    ...
)
    \end{lstlisting}


\section{Exploitation des nouvelles données}

    Afin d'exploiter ces données, nous avons créée deux nouvelles tables centralisant toutes les morts des différentes régions.

    \begin{lstlisting}[frame=single, language=SQL]
SELECT deaths.*
FROM deaths INNER JOIN causes
        ON deaths.cause = causes.cause
WHERE causes.niveau <= 2
    \end{lstlisting}

    Et comme vu précédemment, il existe un gap entre le nombre total de morts si on regarde les causes de niveau 2 ou le nombre
    total de morts (cause de niveau 1).

    \begin{lstlisting}[frame=single, language=SQL]
SELECT causes.niveau, SUM(deaths.deaths)
FROM deaths INNER JOIN causes
        ON deaths.cause = causes.cause
    \end{lstlisting}

